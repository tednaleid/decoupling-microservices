<!doctype html>
<html lang="en">
<head>
	<title>Decoupling Microservices</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=680, user-scalable=no">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="generator" content="https://github.com/sapegin/grunt-shower-markdown">
	<link rel="stylesheet" href="themes/ribbon/styles/screen.css">
	
		<link rel="stylesheet" href="styles/screen.css?1500946928000">
	
</head>
<body class="list">
	<header class="caption">
		<h1 id="decoupling-microservices">Decoupling Microservices</h1>
<p>by <a href="https://twitter.com/tednaleid">@tednaleid</a></p>

	</header>

	
	<section class="slide shout" ><div>
		<h1>Decoupling Microservices</h1>
<h2>by <a href="https://twitter.com/tednaleid">@tednaleid</a></h2>

	</div></section>
	
	<section class="slide quietest shout" ><div>
		<h1>Microservices<br/><br/>&ldquo;loosley coupled Service-Oriented Architecture with bounded contexts&rdquo; <br/><br/>&mdash; Adrian Cockcroft (AWS/Netflix)</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Bounded Contexts</h1>
<h2>from Domain-Driven Design, a conceptual model where <br/>a specific domain model applies</h2>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>Microservices all share a single domain model?</h1>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>You&#39;ve built a<br/>&quot;distributed monolith&quot;</h1>
<h2>Watch: &quot;<a href="https://www.microservices.com/talks/dont-build-a-distributed-monolith/">Don&#39;t Build a Distributed Monolith</a>&quot;<br/>by Ben Christensen (Facebook/Netflix)</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Loosley Coupled</h1>

	</div></section>
	
	<section class="slide quietest shout" ><div>
		<h1>Golden Rule of Component Reliability<br/><br/>any critical component must be 10 times as reliable as the overall system&#39;s target, so that its contribution to system unreliability is noise</h1>
<h2>from: <a href="https://queue.acm.org/detail.cfm?id=3096459">&quot;The Calculus of Service Availability&quot;, ACM Queue, Vol 15, Issue 2</a></h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Tight Coupling</h1>
<h2>Services directly calling services</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Looser Coupling</h1>
<h2>some caching, reverse proxy, grace periods, circuit breakers<br/><br/>issues: cache invalidation rules, cold start/cache flush,<br/>emergency changes, race conditions</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Ideal Coupling</h1>
<h2>totally functional during a partition<br/><br/>only thing more &quot;loose&quot; is no dependency at all</h2>

	</div></section>
	
	<section class="slide quieter shout" ><div>
		<h1>#1 thing you can do for scalability and fault-tolerance?</h1>

	</div></section>
	
	<section class="slide quieter shout" ><div>
		<h1>separate your<br/>reads and writes</h1>
<h2>don&#39;t do this if you don&#39;t need scalability &amp; fault-tolerance</h2>

	</div></section>
	
	<section class="slide quieter shout" ><div>
		<h1>read requests are likely many orders of magnitude more frequent</h1>
<h2>with exceptions (logging/metrics) where writes are <em>far</em> more frequent</h2>

	</div></section>
	
	<section class="slide quieter shout" ><div>
		<h1>write requests have consequences</h1>
<h2>cache-invalidation, notifications, etc</h2>

	</div></section>
	
	<section class="slide quieter shout" ><div>
		<h1>decouple and scale reads with materialized views</h1>
<h2>also called &quot;derived data&quot;</h2>

	</div></section>
	
	<section class="slide quieter shout" ><div>
		<h1>optimized for the query patterns of each microservice</h1>

	</div></section>
	
	<section class="slide quieter shout" ><div>
		<h1>decouple and scale writes with event buffers</h1>
<h2>example patterns include Event Sourcing/CQRS<br/>(Command Query Responsibility Segregation)</h2>

	</div></section>
	
	<section class="slide light" ><div>
		<h1>Separate Reads and Writes</h1>
<img src="images/read_write.png" alt="" height="600px"/>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Kafka</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>A log-based<br/>(append-only) message broker</h1>
<h2>combines databases (durable storage) and messaging (queuing and publish/subscribe)</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Producer (API)<br/>&darr;<br/>Kafka Broker<br/>&darr;<br/>Consumer (API)</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Kafka cluster is made of many brokers</h1>
<h2>uses Zookeeper for leader-election and broker metadata</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Brokers have many named topics</h1>
<h2>replication across brokers configured per topic</h2>

	</div></section>
	
	<section class="slide light" ><div>
		<h1>Each topic has 1..N partitions</h1>
<img src="images/topic_partitions.png" alt="" height="500px"/>

	</div></section>
	
	<section class="slide " ><div>
		<h1>Producers push data to a topic&#39;s partitions<br/><br/><br/></h1>
<pre><code># send message {&quot;id&quot;:&quot;123&quot;, value: &quot;foo&quot;} with key &quot;123&quot;</code>
<code>&shy;</code>
<code>echo &#39;123,{&quot;id&quot;:&quot;123&quot;, value: &quot;foo&quot;}&#39; |\</code>
<code>    kafkacat -P -K &#39;,&#39; -b 127.0.0.1:9092 -t the-topic</code></pre><h2><br/><br/><br/>Message payload is binary data<br/>Can be String/JSON/Avro/Protocol Buffers/Whatever</h2>

	</div></section>
	
	<section class="slide " ><div>
		<h1>Producers can publish lots of data quickly<br/><br/><br/></h1>
<pre><code># send 100,000 messages with key 1 through 100000</code>
<code># and value {&quot;id&quot;: &quot;&lt;#&gt;&quot;, value: &quot;bar&quot;}</code>
<code>&shy;</code>
<code>seq 100000 |\</code>
<code>    awk &#39;{printf &quot;%s,{\&quot;id\&quot;:\&quot;%s\&quot;, value: \&quot;bar\&quot;}\n&quot;, $1, $1}&#39; |\</code>
<code>    kafkacat -P -b 127.0.0.1:9092 -t the-topic -K &#39;,&#39;</code></pre>
	</div></section>
	
	<section class="slide shout" ><div>
		<h1>consistent hashing<br/><br><span style="font-size:70%">messages with the same key always go to the same partition</span></h1>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>Consumers are pull-based<br/><br/><span style="font-size:70%">they maintain per-partition offsets</span></h1>
<h2>by default in a special topic called <code>__consumer_offsets</code></h2>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>Consumption is not destructive<br/><br/><span style="font-size:70%">messages have a retention period (default 24-hours)</span></h1>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>partitions are balanced across a consumer group</h1>
<h2>max # of consumers for a topic is the number of partitions</h2>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>Message compaction keeps one message per key</h1>

	</div></section>
	
	<section class="slide light" ><div>
		<h1>Compaction keeps the latest value per key</h1>
<img src="images/compaction.png" alt="" height="650px"/>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>Kafka Brokers have few<sup>*</sup> moving parts<br/><br/><span style="font-size:60%">focused on speed, reliability, reasonability</span></h1>
<h2><br/><br/><br/><br/>*compared to things like JMS, AMQP, RabbitMQ</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>How does Kafka enable decoupling?</h1>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>if a consumer falls behind the kafka acts as a buffer and doesn&#39;t stop producers</h1>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>multiple specialized consumers can be created<br/><span style="font-size:50%">Elasticsearch index for searching<br/>JSON payload in S3 buckets for SPA<br/>logging/metrics driven off kafka</span></h1>

	</div></section>
	
	<section class="slide light" ><div>
		<h1>scale to multiple availability zones, datacenters, or even multiple cloud providers</h1>
<img src="images/scale_materialized_views.png" alt="" height="500px"/>
<h2>Kafka &quot;MirrorMaker&quot; can mirror the contents of a topic to other kafka clusters</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>materialized views can be thrown away and rebuilt</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>great for blue/green deployments</h1>
<h2>also for replicating data to lower environments</h2>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>clear separation between writes and reads<br/><br/><span style="font-size:70%">if it&#39;s in kafka, it&#39;s downstream, otherwise upstream</span></h1>

	</div></section>
	
	<section class="slide light" ><div>
		<h1>What can create materialized views?</h1>
<img src="images/materialized_view_creator.png" alt="" height="450px"/>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Simple Java/Groovy app with Kafka consumer libraries</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Akka Kafka Streams app</h1>
<h2>or RxJava or Spring Reactor</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Stream processing framework like Spark, Flink, etc</h1>
<h2>Apache alone has 10+ of these, but they tend to be <em>heavy</em></h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Hollow</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Netflix Java API for<br/>non-durable<br/>in-memory caches</h1>
<h2>should never be the source of truth</h2>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>&ldquo;a way to compress your dataset in memory while still providing O(1) access to any portion of it&rdquo; <br/><span style="font-size:50%">- Drew Koszewnik (lead contributor, Netflix)</span></h1>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>megabytes to gigabytes,<br/>but not terabytes</h1>

	</div></section>
	
	<section class="slide shout quieter" ><div>
		<h1>not suitable for every kind of data problem<br/><span style="font-size:70%">but great for the ones it is a fit for</span></h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Single Producer<br/>Many Consumers</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>HollowProducer main components are publisher and announcer</h1>
<h2>TODO better example, details on what publisher writes out, delts, files can be written</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>HollowConsumer main components are BlobRetriever and AnnouncementWatcher</h1>
<h2>consumers define their own index on the data for efficient retrieval</h2>
<h2>if data gets deleted you want to reload the full set on some period schedula (nightly) so orphans don&#39;t hang around forever</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Primary Use Cases</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>read-heavy lookup data where objects change relatively frequently</h1>
<h2>weekly/daily/hourly, but not every second</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Netflix uses it for video metadata</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>why use this over memcached/redis or a full database?</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>initial load at startup then resilient to network partitions</h1>
<h2>resilient to partitions</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>fewer running servers/moving pieces</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>faster response times, no network calls, just memory access</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>When should you use those instead?</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Data size is quite large</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Data changes very frequently</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Data <em>must</em> be consistent across servers</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Other Considerations</h1>

	</div></section>
	
	<section class="slide shout quietest" ><div>
		<h1>Single Producer<br/>need to think about failover (zookeeper/etcd with leader election, multiple hot producers)</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Homework</h1>

	</div></section>
	
	<section class="slide " ><div>
		<h1>Places to Start<br/><br/><a href="https://github.com/Netflix/hollow-reference-implementation">hollow-reference-implementation</a><br/><br/>try hollow for simple lookup data<br/><br/><a href="https://github.com/wurstmeister/kafka-docker/blob/master/docker-compose.yml">kafka/zookeeper docker-compose</a> + <a href="https://github.com/edenhill/kafkacat">kafkacat</a><br/><br/>kafka + telegraf/influx for metrics</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Resources</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Learn More Kafka<br/><br/><a href="https://www.confluent.io/blog/">Confluent&#39;s Blog</a></h1>
<h2><a href="https://www.confluent.io/blog/">https://www.confluent.io/blog/</a></h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Learn More Hollow<br/><br/><a href="http://hollow.how/">Hollow&#39;s Docs</a></h1>
<h2><a href="http://hollow.how/">http://hollow.how/</a></h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<img src="images/DDIA.png" alt="" height="480px"/>
<h2><a href="http://dataintensive.net/">dataintensive.net</a> - ideas for &quot;read-after-write consistency&quot; solutions</h2>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>@tednaleid</h1>

	</div></section>
	
	<section class="slide shout" ><div>
		<h1>Questions?</h1>

	</div></section>
	

	<div class="progress"><div></div></div>
	<script src="shower/shower.min.js"></script>

	
		<script src="node_modules/shower-core/shower.min.js?1449424134000"></script>
	

	

	<!-- Shower: http://shwr.me -->
</body>
</html>